"use client";
import React, { useState } from "react";
import jsPDF from "jspdf";

const LOGO_PATH = "/tortoise-hare-logo.png";
// Brand colours (match your UI updates)
const NAVY = "#1E293B";
const SLATE = "#475569";
const LIGHT = "#F1F5F9";
const BORDER = "#CBD5E1";
const ACCENT = "#38BDF8";

type ChatMessage = { role: "user" | "assistant" | "system"; content: string };

export default function ExportPdfButton({ messages }: { messages: ChatMessage[] }) {
  const [loading, setLoading] = useState(false);

  async function toDataUrl(path: string) {
    const res = await fetch(path);
    const blob = await res.blob();
    return await new Promise<string>((resolve) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as string);
      reader.readAsDataURL(blob);
    });
  }

  async function handleExport() {
    try {
      setLoading(true);

      // 1) Ask API for the summary (send full chat)
const resp = await fetch("/api/export-pdf", {
  method: "POST",
  body: JSON.stringify({ messages }),
  headers: { "Content-Type": "application/json" },
  
});
// Read the stream ONCE
const bodyText = await resp.text();

if (!resp.ok) {
  // Pass through whatever the server returned (often JSON string)
  throw new Error(bodyText || `HTTP ${resp.status}`);
}

let s: {
  issue: string;
  emotion: string;
  shortTermGoal: string;
  longTermGoal: string;
  summary: string;
};

try {
  s = JSON.parse(bodyText);
} catch {
  throw new Error("Server did not return valid JSON.");
}


      // 2) Build branded PDF (client-side)
// -----------------------------------------------------------------------------
const doc = new jsPDF({ unit: "pt", format: "a4" });

// --- measurements / theme
const pageW = doc.internal.pageSize.getWidth();
const pageH = doc.internal.pageSize.getHeight();
const M = 64;                       // page margin
const CARD_GAP = 14;                // space between cards
const LINE = 18;                    // line-height for body text
let y = M;

// --- helpers
const addPageIfNeeded = (neededHeight: number) => {
  if (y + neededHeight > pageH - M) {
    doc.addPage();
    y = M;
  }
};

const drawDivider = () => {
  doc.setDrawColor(BORDER);
  doc.setLineWidth(1);
  doc.line(M, y, pageW - M, y);
  y += 22;
};

const roundedRect = (x: number, y: number, w: number, h: number) => {
  // jsPDF has roundedRect in core builds; if not, fallback to rect
  const hasRounded = typeof (doc as any).roundedRect === "function";
  if (hasRounded) (doc as any).roundedRect(x, y, w, h, 10, 10, "FD");
  else { doc.rect(x, y, w, h, "FD"); }
};

const sectionCard = (label: string, text: string) => {
  const cardX = M;
  const cardW = pageW - M * 2;

  // Add extra breathing room *before* each new section
  y += 28; // <— adjust this value (8–16) to your liking

  // Measure wrapped text height first to decide about page break
  doc.setFont("helvetica", "normal");
  doc.setFontSize(11);
  const body = doc.splitTextToSize((text || "—").trim(), cardW - 24);

  // Slightly increase space below body text
  const contentHeight = 22 /*label*/ + 12 /*spacer*/ + body.length * LINE + 30 /*padding*/;

  addPageIfNeeded(contentHeight);

  // Card background
  doc.setFillColor(LIGHT);
  doc.setDrawColor(BORDER);
  roundedRect(cardX, y, cardW, contentHeight);

  // Label
  doc.setTextColor(ACCENT);
  doc.setFont("helvetica", "bold");
  doc.setFontSize(13);
  doc.text(label, cardX + 12, y + 26); // +26 gives more space from the top

  // Body
  doc.setTextColor(SLATE);
  doc.setFont("helvetica", "normal");
  doc.setFontSize(11);
  let by = y + 26 + 20; // label baseline + spacer
  body.forEach((line: string) => {
    doc.text(line, cardX + 12, by);
    by += LINE;
  });
// Optional subtle divider line between sections
doc.setDrawColor(BORDER);
doc.setLineWidth(0.4);
doc.line(cardX + 8, y + contentHeight + 2, cardX + cardW - 8, y + contentHeight + 2);

  y += contentHeight + CARD_GAP;
};


const center = (txt: string, yy: number) => {
  doc.text(txt, pageW / 2, yy, { align: "center" });
};

// --- header logo
try {
  const dataUrl = await toDataUrl(LOGO_PATH);
  const w = 120, h = 60;
  doc.addImage(dataUrl, "PNG", (pageW - w) / 2, y, w, h);
} catch {}
y += 78;

// --- title
doc.setFont("helvetica", "bold");
doc.setFontSize(26);
doc.setTextColor(NAVY);
center("Tortoise and Hare Chat Summary", y);
y += 18;
drawDivider();

// --- sections (nice compact, consistent, brand-coloured)
sectionCard("Issue", s.issue);
sectionCard("Emotion", s.emotion);
sectionCard("Short-Term Goal", s.shortTermGoal);
sectionCard("Long-Term Goal", s.longTermGoal);
sectionCard("Summary of Chat", s.summary);

// --- footer (optional)
addPageIfNeeded(30);
doc.setFont("helvetica", "normal");
doc.setFontSize(9);
doc.setTextColor(SLATE);
center("Generated by Tortoise & Hare Wellness • " + new Date().toLocaleString(), pageH - M / 2);

doc.save("Tortoise_and_Hare_Chat_Summary.pdf");


    } catch (e: any) {
      alert(`Export failed: ${e?.message || e}`);
    } finally {
      setLoading(false);
    }
  }

  return (
    <button
      onClick={handleExport}
      disabled={loading}
      className="inline-flex items-center rounded-2xl px-4 py-2 shadow-sm bg-sky-500 hover:bg-sky-600 text-white disabled:opacity-60"
     >
      {loading ? "Exporting…" : "Export PDF"}
    </button>
  );
}
